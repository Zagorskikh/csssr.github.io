---
layout:     post
title:      Не так страшен git... а вот так страшен git — `git reset --hard && git push -f`
---

Всем привет! Меня зовут Максим, я верстаю в CSSSR. Есть две ветки. Как насчет фокуса? <s>Я заставлю карандаш исчезнуть</s> я сейчас сделаю `git reset`, `git push -f` и меня никто не побьет!

Не могу вспомнить, как называется этот прием, короче — в заголовок вынесено одно утверждение, а остальной текст его опровергает.

## Интро
Классика жанра - на проекте каждая фича пилится в отдельной ветке. Как только фича готова - ПР в мастер. <b>Важное замечание:</b> пулл-реквест не просто мержится, но еще и [сквошится](https://htmlacademy.ru/blog/27-how-to-squash-commits-and-why-it-is-needed). Это существенно.

Вечер. Фича готова. Делаю ПР в мастер. Позже на мыло приходит сообщение, что ПР смержили. Все отлично.

Утро. В слак-канале проекта вижу следующее сообщение:

>Если ПР смержили, то при продолжении работы сначала мержтесь с мастером, а потом уже работайте.<br>Т.к. мержется оно сквошем, то без мержа будут лишние >конфликты.<br>Еще вариант — не мержится, <b>а резетнуться на мастер.</b> Это еще лучше.

И инструкция
```
git fetch origin master
git reset --hard origin master
git push -f origin branchName
```
> Что здесь происходит?
> Это какая то глупая шутка ?
> -- <cite>Лиам Нисон, к/ф "Неизвестный"</cite>

Какой форспуш? Какой ресет? Да это же самые опасные команды в `git`. Что за ужас здесь творится?! Если по поводу  `fetch`  вопросов не было, то `reset` и `push -f` поставили меня в тупик. `...не мержится, а резетнуться на мастер...не мержится, а резетнуться на мастер` Мне предлагают получить изменения из ветки reset'ом? Это явно что-то дьявольское! (позже я пойму, что нет никакой передачи/получения изменений. Но об этом ниже.)
Попробуем разобраться в "творящемся ужасе". Для этого я в тепличных условиях повторю, те процессы, которы привели к необходимости `ресетиться на master`.
И начнем мы с того...

### ...что такое ветка?
Самое главное, что нужно понимать, ветка - это <b>указатель на коммит<b/>, и этот указатель можно двигать. По умолчанию при создании инициализации репозитория создается указатель `master`. При каждом новом коммите в ветку - указатель передвигается вперед.

Представим себе начальное состояние проекта. *Внимательно изучите каждый коммит.*

![image](/images/gitreset/1.png)

Разметка нашего проекта готова, самое время заняться интерактивной частью. Создадим новую ветку для этого.

Что происходит, когда мы создаем новую ветку? Мы создаем еще один указатель на коммит. Выполним `git checkout -b feature/javascript`

![image](/images/gitreset/2.png)

Что произошло - мы получили еще один указатель. Продолжая работать и коммитить в новой ветке мы будем двигать не указатель `master`, а указатель `feature/javascript`. 5, 10, 15 коммитов в этой ветке, а `master` по-прежнему будет указывать на тот, древний коммит, от которого произошел указатель `feature/javascript`. C этого момента вся история изменеий проекта будет ответвляться от предыдущей версии. Это понятно, это и так все знают.

Пора бы поделиться своим интерактивом на HTML5 и запушить наш проект в удаленный репозиторий. Посмотрим на состояния проекта перед пушем. *Внимательно изучите каждый коммит.*

![image](/images/gitreset/3.png)

### Флэшбек:

<b>Pavel Chekov</b>
Саш, здорова. Не понял твое сообщение про ресет и форспуш, что за дичь то такая?

<b>James Tiberius "Jim" Kirk</b>
Хм...а что вообще проихсодит при пуше?

<b>Pavel Chekov</b>
Ну пушим мы свои изменения. А форспушим,чтобы эти изменения любой ценой накатить))

<b>James Tiberius "Jim" Kirk</b>
Ну... Это очень грубо. Самое время выучить матчасть гита.

И я пошел учить матчасть.

### Наши дни:
Происходит при пуше вот что:
- указатель ветки на сервере передвигается на последний коммит в моей *локальной* ветке.
- передается содержимое всех коммитов, которые нужны новому указателю(на сервере).

![image](/images/gitreset/4.png)

Видите эту красную стрелку? Она указывает, на мой аватар в GitHub.

Теперь и у меня дома и на сервере GitHub в США абсолютноо идентичные ветки, указатели которых находятся на одном и том же коммите.

**Важно** - для успешного пуша на сервер, нужно одно обязательное условие - *Тот коммит, который пушится, должен быть прямым потомком того, что сейчас на сервере*

Удостоверимся в этом. Делаем коммит. И видим, что указатели локальный и серверный разделились.
![image](/images/gitreset/5.png)

В таком варианте пуш в `feature/javascript` произойдет успешно. Потому что наш локальный коммит прямой потомок коммита, на котором сейчас серверная ветка. Делаем `git push origin feature/javascript`.

![image](/images/gitreset/6.png)

И правда, указатель серверной ветки передвинулся, и у нас снова абосолютно идентичное состояние проекта локально и серверно.

Я на время оставляю проект, а позже open source community откликается, и решает перевести проект на React+flux. Похвальное стремление. Они быстренько бранчатся от `feature/javascript`  проводят свои бесчеловечные эксперименты и пушат все. Куда? в `feature/javascript`, конечно, и им ничто не помешало этого сделать. Почему? Все по той же причине, ветка 'feature/react' имеет того же самого прямого предка-коммита, на который сейчас указывает 'feature/javascript' серверно. При этом серверный указатель сдвинулся на новый коммит. В общем пока ничего нового.

![image](/images/gitreset/7.png)

Серверная `feature/javascript` не исчезла, теперь она указывает на тот же коммит, что и `feature/react`

Я возвращаюсь к работе в своей ветке, делаю коммит. Состояние проекта в тот момент - я ничего не знаю про переход на React.

![image](/images/gitreset/8.png)

Делаю `git push origin feature/javascript`. И вижу **это**...

![image](/images/gitreset/9.png)

Если коротко, то указатель серверный и указатель локально не имеют общего предка. Запушить не получится.
Не желая мириться с React'ом и стрелками в пропсах, я делаю `git push -f origin feature/javascript`. Все таки мне предложили это, как альтернативный вариант.

Состояние проекта после форспуша:

![image](/images/gitreset/10.png)

Все, готово. React оказался за бортом проекта.

Указатель на сервере передвинулся **назад в прошлое!** Раскрываю подробности: сущность гита такова, что при обычном пуше указатель на сервере может двигаться только вперед. С форспушем ситуация иная.

Форспуш — это такой диктат злобной воли неопытного разработчика: **_передвинь указатель ветки на сервере на коммит, который у меня сейчас локально, даже если это не прямой родитель. Даже, если это что угодно_**.

Форспуш может двигать указатель назад, вперед, туда, куда я скажу. В `feature/react` было 500 коммитов(к примеру) или идеальный интерфейс, а я форспушем передвинул серверный указатель на свой коммит, где eval() и сборка на Grunt. И это может уйти в прод, а дальше смерть... Иными словами — это пример того, как делать **не надо**. В этом случае git действительно "страшен".

И сейчас самое время перейти к позитивной части.

### Укрощаем ветку

Пока что в моем повествовании форспуш роль отрицательного персонажа играет, пора реабилитироваться. Для этого я подготовил упрощенную версию проекта.

![image](/images/gitreset/11.png)

Вернемся к первопричине всего, к тому как мержатся ПРы. В моем случае ПР мержатся сквошем. Что это значит? Это значит — я создаю ОДИН НОВЫЙ КОММИТ. В котором все правки старых вместе взятых. Взгляните на скриншот:

![image](/images/gitreset/12.png)

![image](/images/gitreset/12.1.png)

`Feature/javascript(#2)` содержит в себе измененения от коммитов I, J и K, но это все равно новый коммит!

Следом за мной, в `master` сквошатся умельцы из [#react-learning-club](https://www.youtube.com/channel/UCwGUpAUuPcy6Q0Yc9gDXwPA) (React+redux, все как надо).

![image](/images/gitreset/13.png)

Так вот, чтобы получить актуальные изменения, сейчас мне надо смержится с `master` **...при продолжении работы сначала мержтесь с мастером..** Припоминаете? Это то с чего началась моя статья. Но, получив изменения по React'у, я также получу и изменения от коммитов I, J и K, которые уже есть уменя в ветке! Произойдет дублирование содержимого — это плохо.

Поэтому сделаем `git reset --hard origin master`. Что произошло?

![image](/images/gitreset/14.png)

Теперь указатель `feature/javascript` указывает на `master`. При этом в `feature/javascript` есть и последние актуальные изменения по React'у и нет дублирования моих же коммитов. Вот на этом моменте можно подумать что reset'ом слили изменения из другой ветки. Это не так, мы просто передвинули указатель на ту ветку, где все изменения уже есть.

Но что если мы захотим добавить еще что-то? `git commit -m "O"` `git push origin feature/javascript`. внимательный читатель уже без скриншота скажет, что запушить изменения в этом случае не получится - последний коммит K(серверный) и коммит O(локальный) не являются прямыми родственниками.

![image](/images/gitreset/15.png)

Поэтому делаем `git push -f origin feature/javascript` -серверный указатель сдвигается на наш локальный и при этом никакие данные не теряются. Еще коммитим, пушим, сквошим и работа окончена.

![image](/images/gitreset/16.png)

Итоговое комбо: Работаем в ветке -> сквошимся в мастер -> кто то еще сковшится в мастер -> делаем хард ресет на мастер, чтобы избежать задваивания содержимого -> запушить в свою ветку просто так неполучится(коммиты не родственные) -> делаем форспуш в свою ветку(сейчас можно, потому что в мастере уже есть предыдушие правки) -> cквошим в мастер новые коммиты -> `вниз вперед квадрат икс` Hadooooouken!

![image](/images/gitreset/hadouken.jpg)

## Заключение

Статья не претендует статус академического исследования. Это, скорее, путевые заметки, эпизод из рабочей ситуации. И вывод довольно тривиальный - хотя бы изредка заглядывайте в доку гита, и самые "опасные" его команды станут вашими союзниками.
